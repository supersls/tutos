"use strict";(self.webpackChunktutos=self.webpackChunktutos||[]).push([[2512],{8450:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>i});var t=r(4848),a=r(8453);const o={},c=void 0,s={id:"java/ThreadDeadLock",title:"ThreadDeadLock",description:"A deadlock in Java occurs when two or more threads are blocked forever, each waiting for the other to release a resource that it holds. Here's a simple example of a deadlock scenario:",source:"@site/docs/java/ThreadDeadLock.md",sourceDirName:"java",slug:"/java/ThreadDeadLock",permalink:"/tutos/docs/java/ThreadDeadLock",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java/ThreadDeadLock.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"JEE",permalink:"/tutos/docs/java/JEE"},next:{title:"appLifeCycle",permalink:"/tutos/docs/java/appLifeCycle"}},d={},i=[];function l(e){const n={code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"A deadlock in Java occurs when two or more threads are blocked forever, each waiting for the other to release a resource that it holds. Here's a simple example of a deadlock scenario:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public class DeadlockExample {\n    private static Object lock1 = new Object();\n    private static Object lock2 = new Object();\n\n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -> {\n            synchronized (lock1) {\n                System.out.println("Thread 1 acquired lock1");\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println("Thread 1 trying to acquire lock2");\n                synchronized (lock2) {\n                    System.out.println("Thread 1 acquired lock2");\n                }\n            }\n        });\n\n        Thread thread2 = new Thread(() -> {\n            synchronized (lock2) {\n                System.out.println("Thread 2 acquired lock2");\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println("Thread 2 trying to acquire lock1");\n                synchronized (lock1) {\n                    System.out.println("Thread 2 acquired lock1");\n                }\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["We have two threads, ",(0,t.jsx)(n.code,{children:"thread1"})," and ",(0,t.jsx)(n.code,{children:"thread2"}),", both of which acquire locks on ",(0,t.jsx)(n.code,{children:"lock1"})," and ",(0,t.jsx)(n.code,{children:"lock2"}),", but in different orders."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"thread1"})," acquires ",(0,t.jsx)(n.code,{children:"lock1"})," and then tries to acquire ",(0,t.jsx)(n.code,{children:"lock2"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Meanwhile, ",(0,t.jsx)(n.code,{children:"thread2"})," acquires ",(0,t.jsx)(n.code,{children:"lock2"})," and then tries to acquire ",(0,t.jsx)(n.code,{children:"lock1"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"thread1"})," and ",(0,t.jsx)(n.code,{children:"thread2"})," run concurrently, a deadlock occurs because each thread holds one lock while waiting for the other to release the lock it needs."]}),"\n",(0,t.jsx)(n.li,{children:"As a result, both threads remain blocked forever, and the program does not make any progress."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Deadlocks are a common problem in multithreaded programming, and they can be tricky to debug and resolve. To avoid deadlocks, you should always be cautious when acquiring multiple locks and try to acquire locks in a consistent order across threads. Additionally, using higher-level synchronization mechanisms such as ",(0,t.jsx)(n.code,{children:"java.util.concurrent"})," classes can help prevent deadlocks by providing more controlled ways to manage locks and resources."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>s});var t=r(6540);const a={},o=t.createContext(a);function c(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);