"use strict";(self.webpackChunktutos=self.webpackChunktutos||[]).push([[9052],{8046:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var r=i(4848),t=i(8453);const a={},s=void 0,o={id:"craftsmanChip/DDD",title:"DDD",description:"Domain-Driven Design (DDD) is an architectural approach that emphasizes the importance of the domain model within a software application. It focuses on understanding and modeling the business domain, capturing its complexity, and mapping it to the software implementation effectively. Here's a simplified example of Domain-Driven Design in a Java application:",source:"@site/docs/craftsmanChip/DDD.md",sourceDirName:"craftsmanChip",slug:"/craftsmanChip/DDD",permalink:"/tutos/docs/craftsmanChip/DDD",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/craftsmanChip/DDD.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"crafsmanChip",permalink:"/tutos/docs/category/crafsmanchip"},next:{title:"clean-code",permalink:"/tutos/docs/craftsmanChip/clean-code"}},c={},d=[{value:"1. Define the Domain Model:",id:"1-define-the-domain-model",level:3},{value:"2. Define Repositories:",id:"2-define-repositories",level:3},{value:"3. Define Services:",id:"3-define-services",level:3},{value:"4. Application Layer:",id:"4-application-layer",level:3},{value:"5. Infrastructure Layer:",id:"5-infrastructure-layer",level:3},{value:"6. Application Bootstrapping:",id:"6-application-bootstrapping",level:3},{value:"Conclusion:",id:"conclusion",level:3}];function l(e){const n={code:"code",h3:"h3",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Domain-Driven Design (DDD) is an architectural approach that emphasizes the importance of the domain model within a software application. It focuses on understanding and modeling the business domain, capturing its complexity, and mapping it to the software implementation effectively. Here's a simplified example of Domain-Driven Design in a Java application:"}),"\n",(0,r.jsx)(n.h3,{id:"1-define-the-domain-model",children:"1. Define the Domain Model:"}),"\n",(0,r.jsxs)(n.p,{children:["Let's consider a simple e-commerce application with entities like ",(0,r.jsx)(n.code,{children:"Product"}),", ",(0,r.jsx)(n.code,{children:"Order"}),", and ",(0,r.jsx)(n.code,{children:"Customer"}),". These entities represent the core concepts of the domain:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class Product {\n    private Long id;\n    private String name;\n    private double price;\n    // Constructors, getters, and setters\n}\n\npublic class Order {\n    private Long id;\n    private Customer customer;\n    private List<Product> products;\n    // Constructors, getters, and setters\n}\n\npublic class Customer {\n    private Long id;\n    private String name;\n    private String email;\n    // Constructors, getters, and setters\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-define-repositories",children:"2. Define Repositories:"}),"\n",(0,r.jsx)(n.p,{children:"Repositories are responsible for persisting and retrieving domain objects from the database. They provide an abstraction layer between the domain model and the data access logic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface ProductRepository {\n    Product findById(Long id);\n    void save(Product product);\n    void delete(Long id);\n    // Other methods\n}\n\npublic interface OrderRepository {\n    Order findById(Long id);\n    void save(Order order);\n    void delete(Long id);\n    // Other methods\n}\n\npublic interface CustomerRepository {\n    Customer findById(Long id);\n    void save(Customer customer);\n    void delete(Long id);\n    // Other methods\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-define-services",children:"3. Define Services:"}),"\n",(0,r.jsx)(n.p,{children:"Services encapsulate the business logic and orchestrate interactions between different domain objects. They ensure that business rules are enforced and transactions are managed properly:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public class OrderService {\n    private OrderRepository orderRepository;\n\n    public OrderService(OrderRepository orderRepository) {\n        this.orderRepository = orderRepository;\n    }\n\n    public void placeOrder(Order order) {\n        // Business logic for placing an order\n        orderRepository.save(order);\n    }\n\n    // Other business methods\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-application-layer",children:"4. Application Layer:"}),"\n",(0,r.jsx)(n.p,{children:"The application layer consists of controllers, facades, or use cases that interact with the domain model and expose functionalities to external clients (e.g., REST APIs, web interfaces):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'@RestController\n@RequestMapping("/orders")\npublic class OrderController {\n    private OrderService orderService;\n\n    @PostMapping\n    public ResponseEntity<Void> placeOrder(@RequestBody Order order) {\n        orderService.placeOrder(order);\n        return ResponseEntity.ok().build();\n    }\n\n    // Other controller methods\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"5-infrastructure-layer",children:"5. Infrastructure Layer:"}),"\n",(0,r.jsx)(n.p,{children:"The infrastructure layer handles technical concerns such as database access, messaging, and external services integration. It provides implementations for repositories and other infrastructure components:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@Repository\npublic class JpaOrderRepository implements OrderRepository {\n    // Implementations for OrderRepository methods using JPA\n}\n\n@Service\npublic class EmailService {\n    // Implementation for sending emails\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"6-application-bootstrapping",children:"6. Application Bootstrapping:"}),"\n",(0,r.jsx)(n.p,{children:"Finally, you need to bootstrap and configure your application components using a framework like Spring Boot or Jakarta EE:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"@SpringBootApplication\npublic class ECommerceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ECommerceApplication.class, args);\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"conclusion",children:"Conclusion:"}),"\n",(0,r.jsx)(n.p,{children:"This example demonstrates the fundamental principles of Domain-Driven Design in a Java application. By focusing on the domain model and leveraging concepts like entities, repositories, services, and application layers, you can create a well-structured and maintainable software architecture that aligns closely with the business requirements. Remember that DDD is a complex topic, and the actual implementation may vary based on the specific needs and complexity of your domain."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(6540);const t={},a=r.createContext(t);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);