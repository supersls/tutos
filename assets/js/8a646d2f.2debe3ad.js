"use strict";(self.webpackChunktutos=self.webpackChunktutos||[]).push([[5054],{4297:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var t=n(4848),r=n(8453);const s={},i=void 0,o={id:"java/java_memory",title:"java_memory",description:"Java Heap Space and Java Stack Space are two distinct memory areas in the Java Virtual Machine (JVM) with different purposes and characteristics:",source:"@site/docs/java/java_memory.md",sourceDirName:"java",slug:"/java/java_memory",permalink:"/tutos/docs/java/java_memory",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java/java_memory.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"hashset",permalink:"/tutos/docs/java/hashset"},next:{title:"jvm",permalink:"/tutos/docs/java/jvm"}},l={},c=[];function d(e){const a={code:"code",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.p,{children:"Java Heap Space and Java Stack Space are two distinct memory areas in the Java Virtual Machine (JVM) with different purposes and characteristics:"}),"\n",(0,t.jsxs)(a.ol,{children:["\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Java Heap Space"}),":"]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"The Java Heap Space is a region of memory used for dynamic memory allocation for Java objects."}),"\n",(0,t.jsx)(a.li,{children:"It's where objects created by Java applications are stored."}),"\n",(0,t.jsx)(a.li,{children:"The heap space is shared among all threads in the JVM."}),"\n",(0,t.jsxs)(a.li,{children:["The size of the heap space can be adjusted using JVM options such as ",(0,t.jsx)(a.code,{children:"-Xmx"})," (maximum heap size) and ",(0,t.jsx)(a.code,{children:"-Xms"})," (initial heap size)."]}),"\n",(0,t.jsx)(a.li,{children:"The heap is divided into two main areas: the Young Generation (Eden space, Survivor spaces) and the Old Generation (Tenured space)."}),"\n",(0,t.jsx)(a.li,{children:"The garbage collector manages the heap space, reclaiming memory from objects that are no longer referenced or in use."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Java Stack Space"}),":"]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsx)(a.li,{children:"The Java Stack Space is a region of memory used for method invocations and storing local variables."}),"\n",(0,t.jsx)(a.li,{children:"Each thread in a Java application has its own stack space, which is private to that thread."}),"\n",(0,t.jsx)(a.li,{children:"The stack space is used for method calls, local variables, and method parameters."}),"\n",(0,t.jsx)(a.li,{children:"The size of the stack space is typically smaller than the heap space and is fixed for each thread."}),"\n",(0,t.jsx)(a.li,{children:"Stack space is managed automatically by the JVM, and it's usually not configurable by the application."}),"\n",(0,t.jsxs)(a.li,{children:["If a thread's stack space is exhausted (e.g., due to deep recursion), a ",(0,t.jsx)(a.code,{children:"StackOverflowError"})," is thrown."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"In summary, the Java Heap Space is used for storing objects dynamically allocated by Java applications, while the Java Stack Space is used for managing method invocations and local variables within threads. Understanding the differences and characteristics of these memory areas is essential for efficient memory management and troubleshooting memory-related issues in Java applications."}),"\n",(0,t.jsx)(a.p,{children:"Java memory management is handled by the Java Virtual Machine (JVM), which abstracts away many of the complexities of memory management from the developer. However, understanding the basics of Java memory management is crucial for writing efficient and robust Java applications. Here's an overview:"}),"\n",(0,t.jsxs)(a.ol,{children:["\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Automatic Memory Allocation and Deallocation"}),": In Java, memory allocation and deallocation are handled automatically by the JVM. When you create an object using the ",(0,t.jsx)(a.code,{children:"new"})," keyword, memory is allocated for that object on the heap. When the object is no longer referenced by any part of the program, it becomes eligible for garbage collection, and the memory occupied by the object is reclaimed."]}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Garbage Collection"}),": Garbage collection is the process by which the JVM identifies and removes objects that are no longer in use from memory. The JVM periodically runs the garbage collector to reclaim memory occupied by unreachable objects. The garbage collector employs different algorithms (e.g., Mark and Sweep, Generational) to manage memory efficiently."]}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Memory Areas in the JVM"}),":"]}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Heap"}),": The heap is the primary area of memory used for storing objects created by Java applications. It's shared among all threads in the JVM and is managed by the garbage collector."]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Stack"}),": Each thread in a Java application has its own stack, which is used for method invocations, local variables, and method parameters. Stack memory is much smaller than heap memory and is used for short-lived data."]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Method Area (PermGen/Metaspace)"}),": The method area stores class metadata, method bytecode, and other static data. In older versions of Java, this area was called the Permanent Generation (PermGen). In newer versions, it's referred to as Metaspace."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Memory Leaks"}),": While Java's garbage collector helps manage memory efficiently, memory leaks can still occur if objects are unintentionally kept in memory longer than necessary. Memory leaks often result from holding references to objects longer than required, preventing them from being garbage collected. Common causes of memory leaks include static references, unclosed resources (such as streams), and circular references."]}),"\n"]}),"\n",(0,t.jsxs)(a.li,{children:["\n",(0,t.jsxs)(a.p,{children:[(0,t.jsx)(a.strong,{children:"Tuning JVM Memory Parameters"}),": Developers can tune JVM memory parameters to optimize memory usage and performance based on the characteristics of their applications. Parameters like ",(0,t.jsx)(a.code,{children:"-Xmx"})," (maximum heap size) and ",(0,t.jsx)(a.code,{children:"-Xms"})," (initial heap size) allow you to adjust the heap size. Similarly, ",(0,t.jsx)(a.code,{children:"-Xss"})," sets the stack size, and ",(0,t.jsx)(a.code,{children:"-XX:MaxMetaspaceSize"})," controls Metaspace size."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:"Understanding Java memory management principles and practices helps developers write efficient, scalable, and reliable Java applications while avoiding memory-related issues like memory leaks and out-of-memory errors."}),"\n",(0,t.jsx)(a.p,{children:"A memory leak in Java occurs when objects are no longer needed by the application but are still referenced, preventing them from being garbage collected. Over time, these unreferenced objects consume memory, leading to increased memory usage and potentially causing out-of-memory errors."}),"\n",(0,t.jsx)(a.p,{children:"Here's a simple example of a memory leak in Java:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:'import java.util.ArrayList;\nimport java.util.List;\n\npublic class MemoryLeakExample {\n    private static List<byte[]> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        while (true) {\n            byte[] bytes = new byte[1024 * 1024]; // Allocate 1MB of memory\n            list.add(bytes); // Add the byte array to the list\n            System.out.println("Allocated 1MB of memory. Total memory: " + list.size() + "MB");\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(a.p,{children:"In this example, we have a simple Java program that continuously allocates 1MB byte arrays and adds them to an ArrayList. However, we never remove or dereference these byte arrays, causing them to accumulate in memory."}),"\n",(0,t.jsxs)(a.p,{children:["As the program runs, it consumes more and more memory without releasing any of the allocated memory. Eventually, the JVM will run out of memory and throw an ",(0,t.jsx)(a.code,{children:"OutOfMemoryError"}),"."]}),"\n",(0,t.jsx)(a.p,{children:"To fix this memory leak, we need to ensure that objects are properly dereferenced when they are no longer needed. In this example, we can modify the program to remove the byte arrays from the list when they are no longer needed:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-java",children:'import java.util.ArrayList;\nimport java.util.List;\n\npublic class MemoryLeakExampleFixed {\n    private static List<byte[]> list = new ArrayList<>();\n\n    public static void main(String[] args) {\n        while (true) {\n            byte[] bytes = new byte[1024 * 1024]; // Allocate 1MB of memory\n            list.add(bytes); // Add the byte array to the list\n            System.out.println("Allocated 1MB of memory. Total memory: " + list.size() + "MB");\n          \n            // Remove objects from the list periodically to avoid memory leak\n            if (list.size() > 10) {\n                list.remove(0);\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(a.p,{children:"In the fixed example, we remove elements from the list periodically to ensure that the list does not grow indefinitely. This prevents the memory leak and allows the program to run without running out of memory."})]})}function m(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>o});var t=n(6540);const r={},s=t.createContext(r);function i(e){const a=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);