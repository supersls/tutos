"use strict";(self.webpackChunktutos=self.webpackChunktutos||[]).push([[7285],{3339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var s=t(4848),a=t(8453);const r={},i=void 0,o={id:"java/hashset",title:"hashset",description:"Certainly! Below is an explanation of the HashSet implementation in Java, formatted in Markdown:",source:"@site/docs/java/hashset.md",sourceDirName:"java",slug:"/java/hashset",permalink:"/docs/java/hashset",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/java/hashset.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"hashmap",permalink:"/docs/java/hashmap"},next:{title:"log4j",permalink:"/docs/java/log4j"}},l={},h=[{value:"Explanation:",id:"explanation",level:3},{value:"HashSet",id:"hashset",level:3},{value:"HashMap",id:"hashmap",level:3},{value:"Key Differences",id:"key-differences",level:3}];function d(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Certainly! Below is an explanation of the HashSet implementation in Java, formatted in Markdown:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'import java.util.HashSet;\nimport java.util.Iterator;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a HashSet of strings\n        HashSet<String> set = new HashSet<>();\n\n        // Adding elements to the HashSet\n        set.add("Apple");\n        set.add("Banana");\n        set.add("Orange");\n\n        // Display the HashSet\n        System.out.println("HashSet: " + set);\n\n        // Check if an element is present\n        String searchElement = "Apple";\n        if (set.contains(searchElement)) {\n            System.out.println(searchElement + " is present in the HashSet.");\n        } else {\n            System.out.println(searchElement + " is not present in the HashSet.");\n        }\n\n        // Remove an element from the HashSet\n        String removeElement = "Banana";\n        if (set.remove(removeElement)) {\n            System.out.println(removeElement + " is removed from the HashSet.");\n        } else {\n            System.out.println(removeElement + " is not present in the HashSet.");\n        }\n\n        // Iterate over the elements of the HashSet\n        System.out.println("Iterating over the elements of the HashSet:");\n        Iterator<String> iterator = set.iterator();\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n\n        // Clear the HashSet\n        set.clear();\n        System.out.println("HashSet is cleared: " + set);\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"explanation",children:"Explanation:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"HashSet Initialization"}),": We import the ",(0,s.jsx)(n.code,{children:"HashSet"})," class from the ",(0,s.jsx)(n.code,{children:"java.util"})," package."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Adding Elements"}),': We add elements "Apple", "Banana", and "Orange" to the HashSet using the ',(0,s.jsx)(n.code,{children:"add()"})," method."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Displaying the HashSet"}),": We print the contents of the HashSet using ",(0,s.jsx)(n.code,{children:"System.out.println()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Checking for Element Existence"}),': We check if "Apple" is present in the HashSet using the ',(0,s.jsx)(n.code,{children:"contains()"})," method."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Removing an Element"}),': We remove "Banana" from the HashSet using the ',(0,s.jsx)(n.code,{children:"remove()"})," method."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Iterating over Elements"}),": We use an ",(0,s.jsx)(n.code,{children:"Iterator"})," to iterate over the elements of the HashSet and print each element."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clearing the HashSet"}),": We use the ",(0,s.jsx)(n.code,{children:"clear()"})," method to remove all elements from the HashSet."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Here's a comparison of HashSet and HashMap in Java, formatted in Markdown:"}),"\n",(0,s.jsx)(n.h3,{id:"hashset",children:"HashSet"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implementation"}),": HashSet implements the Set interface and uses a hash table for storage."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Duplicates"}),": Does not allow duplicate elements. If you try to add a duplicate element, it will be ignored."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Order"}),": Does not guarantee the order of elements. The elements are stored in no particular order."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": Useful for storing a unique collection of elements where order is not important."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Methods"}),": Supports operations like ",(0,s.jsx)(n.code,{children:"add()"}),", ",(0,s.jsx)(n.code,{children:"remove()"}),", ",(0,s.jsx)(n.code,{children:"contains()"}),", and ",(0,s.jsx)(n.code,{children:"clear()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'HashSet<String> set = new HashSet<>();\nset.add("Apple");\nset.add("Banana");\nset.add("Orange");\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"hashmap",children:"HashMap"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Implementation"}),": HashMap implements the Map interface and stores key-value pairs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Duplicates"}),": Does not allow duplicate keys. If you try to add a duplicate key, it will replace the existing value."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Order"}),": Does not guarantee the order of elements. The elements are stored based on the hash codes of keys."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Usage"}),": Useful for key-value mappings where you need fast lookup based on keys."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Methods"}),": Supports operations like ",(0,s.jsx)(n.code,{children:"put()"}),", ",(0,s.jsx)(n.code,{children:"get()"}),", ",(0,s.jsx)(n.code,{children:"remove()"}),", and ",(0,s.jsx)(n.code,{children:"containsKey()"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'HashMap<Integer, String> map = new HashMap<>();\nmap.put(1, "Apple");\nmap.put(2, "Banana");\nmap.put(3, "Orange");\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": HashSet is used to store a collection of unique elements, while HashMap is used to store key-value pairs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": HashSet provides constant-time performance for basic operations like ",(0,s.jsx)(n.code,{children:"add()"}),", ",(0,s.jsx)(n.code,{children:"remove()"}),", and ",(0,s.jsx)(n.code,{children:"contains()"}),". HashMap provides constant-time performance for basic operations like ",(0,s.jsx)(n.code,{children:"get()"})," and ",(0,s.jsx)(n.code,{children:"put()"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Both HashSet and HashMap use hashing internally to achieve constant-time performance for basic operations, but they serve different purposes and have different methods for manipulation. Choose HashSet when you need to store a unique collection of elements, and choose HashMap when you need to store key-value mappings."})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);